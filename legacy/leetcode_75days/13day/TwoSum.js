// 1. Two Sum// Easy//// 36040//// 1144//// Add to List//// Share// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.////     You may assume that each input would have exactly one solution, and you may not use the same element twice.////     You can return the answer in any order.////////     Example 1://// Input: nums = [2,7,11,15], target = 9// Output: [0,1]// Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].//     Example 2://// Input: nums = [3,2,4], target = 6// Output: [1,2]// Example 3://// Input: nums = [3,3], target = 6// Output: [0,1]////// Constraints:////     2 <= nums.length <= 104//     -109 <= nums[i] <= 109//     -109 <= target <= 109// Only one valid answer exists.//////     Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?//     Accepted//     7,424,799// Submissions// 15,168,134var twoSum = function(nums, target) {//     let newNums = nums.map((el,idx)=>[el,idx])//     let sortedNums = newNums.sort((tapeEquilibrium.js,b)=> tapeEquilibrium.js[0]-b[0])//     let left = 0//     let right = sortedNums.length -1//     while(true){//         let sum = sortedNums[left][0] + sortedNums[right][0]//         if(sum === target){//             return [sortedNums[left][1],sortedNums[right][1]]//         }//         if(sum > target){//             right--//         }//         if(sum < target){//             left ++//         }//     }//     let map = new Map();//     for(let i = 0; i < nums.length; i ++) {//         if(map.has(target - nums[i])) {//             return [map.get(target - nums[i]), i];//         } else {//             map.set(nums[i], i);//         }//     }// 	return [];    let hash = {};    for(let i = 0; i < nums.length; i++) {        const n = nums[i];        if(hash[target - n] !== undefined) {            return [hash[target - n], i];        }        hash[n] = i;    }    return [];};