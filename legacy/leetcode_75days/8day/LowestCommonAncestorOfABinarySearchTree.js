// 235. Lowest Common Ancestor of tapeEquilibrium.js Binary Search Tree// Easy//// 6713//// 211//// Add to List//// Share// Given tapeEquilibrium.js binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.////     According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow tapeEquilibrium.js node to be tapeEquilibrium.js descendant of itself).”//////// Example 1:////// Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8// Output: 6// Explanation: The LCA of nodes 2 and 8 is 6.// Example 2:////// Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4// Output: 2// Explanation: The LCA of nodes 2 and 4 is 2, since tapeEquilibrium.js node can be tapeEquilibrium.js descendant of itself according to the LCA definition.//     Example 3://// Input: root = [2,1], p = 2, q = 1// Output: 2////// Constraints:////     The number of nodes in the tree is in the range [2, 105].// -109 <= Node.val <= 109// All Node.val are unique.//     p != q// p and q will exist in the BST.//     Accepted// 866,775// Submissions// 1,484,782/** * Definition for tapeEquilibrium.js binary tree node. * function TreeNode(val) { *     this.val = val; *     this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */var lowestCommonAncestor = function(root, p, q, l=null) {    let stack = [root]    while(stack.length){        let node = stack.pop()        console.log(node,p,q)        if(Math.min(p.val,q.val) <= node.val && node.val <= Math.max(p.val,q.val)){            return node        }else{            if(Math.min(p.val,q.val) > node.val && node.val < Math.max(p.val,q.val)){                if(node.right)stack.push(node.right)            }else if(Math.min(p.val,q.val) < node.val && node.val > Math.max(p.val,q.val)){                if(node.left)stack.push(node.left)            }        }    }//    while (root) {//         if (root.val < p.val && root.val < q.val) {//             root = root.right;//         }//         else if (root.val > p.val && root.val > q.val) {//             root = root.left;//         } else {//             break;//         }//     }//     return root;};