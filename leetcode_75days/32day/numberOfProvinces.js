// 547. Number of Provinces// Medium//// 6502//// 270//// Add to List//// Share// There are n cities. Some of them are connected, while some are not. If city tapeEquilibrium.js is connected directly with city b, and city b is connected directly with city c, then city tapeEquilibrium.js is connected indirectly with city c.////     A province is tapeEquilibrium.js group of directly or indirectly connected cities and no other cities outside of the group.////     You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.////     Return the total number of provinces.////////     Example 1:////// Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]// Output: 2// Example 2:////// Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]// Output: 3////// Constraints:////     1 <= n <= 200// n == isConnected.length// n == isConnected[i].length// isConnected[i][j] is 1 or 0.// isConnected[i][i] == 1// isConnected[i][j] == isConnected[j][i]// Accepted// 556,626// Submissions// 879,263/** * @param {number[][]} isConnected * @return {number} */// const findCircleNum = function(isConnected) {//     let cnt = 0////     const dfs = (position) => {//         let [x,y] = position////         isConnected[y][x] = 0//         let d = [[0,1],[0,-1],[1,0],[-1,0]]////         for(let i =0 ; i<d.length; i++){//             let [dx,dy] = d[i]//             if(isConnected[y+dy] !==undefined && isConnected[y+dy][x+dy] !==undefined && isConnected[y+dy][x+dx] !== 0){//                 isConnected[y+dy][x+dx] = 0//                 dfs([x+dy,y+dy])//             }//         }//     }////     for(let i=0; i<isConnected.length; i++){//         for(let n =0; n<isConnected[i].length ; n++){//             if(isConnected[i][n]===1){//                 cnt++//                 dfs([n,i])//             }//         }//     }//     return cnt// };/** * @param {number[][]} isConnected * @return {number} *//** * @param {number[][]} isConnected * @return {number} */const findCircleNum = function(isConnected) {    let check = new Set()    let cnt = 0    const dfs = (i) => {        for(let n =0; n<isConnected[i].length; n++){            if(!check.has(n) && isConnected[i][n] ===1){                check.add(n)                dfs(n)            }        }    }    for(let i =0; i<isConnected.length ; i++){        if(!check.has(i)){            dfs(i)            cnt++        }    }    return cnt};const findCircleNum2 = function(isConnected) {    class UnionFind {        constructor(n) {            this.graph = [...Array(n)].map((_,idx)=>idx)            this.groups = n        }        find(id){            console.log(this.graph, id)            if(this.graph[id]===id)return id            else{                this.graph[id] = this.find(this.graph[id])                return this.graph[id]            }        }        union(x,y){            const rootX = this.find(x)            const rootY = this.find(y)            if(rootX !== rootY){                this.graph[rootY] = rootX                this.groups--            }        }    }    const length = isConnected.length , unionFind= new UnionFind(length)    for(let i=0; i<length; i++){        for(let n=0; n<isConnected[i].length; n++){            if(isConnected[i][n]===1){                unionFind.union(i,n)            }        }    }    return unionFind.groups};console.log(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]))console.log(findCircleNum([[1,0,0],[0,1,0],[0,0,1]]))console.log(findCircleNum2([[1,1,0],[1,1,0],[0,0,1]]))console.log(findCircleNum2([[1,0,0],[0,1,0],[0,0,1]]))