// 947. Most Stones Removed with Same Row or Column// Medium//// 3057//// 534//// Add to List//// Share// On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.////     A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.////     Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.////////     Example 1://// Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]// Output: 5// Explanation: One way to remove 5 stones is as follows://     1. Remove stone [2,2] because it shares the same row as [2,1].// 2. Remove stone [2,1] because it shares the same column as [0,1].// 3. Remove stone [1,2] because it shares the same row as [1,0].// 4. Remove stone [1,0] because it shares the same column as [0,0].// 5. Remove stone [0,1] because it shares the same row as [0,0].//     Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.//     Example 2://// Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]// Output: 3// Explanation: One way to make 3 moves is as follows://     1. Remove stone [2,2] because it shares the same row as [2,0].// 2. Remove stone [2,0] because it shares the same column as [0,0].// 3. Remove stone [0,2] because it shares the same row as [0,0].//     Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.//     Example 3://// Input: stones = [[0,0]]// Output: 0// Explanation: [0,0] is the only stone on the plane, so you cannot remove it.//////     Constraints://// 1 <= stones.length <= 1000// 0 <= xi, yi <= 104// No two stones are at the same coordinate point.//     Accepted// 123,140// Submissions// 215,591/** * @param {number[][]} stones * @return {number} */const removeStones = function(stones) {    class UnionFind {        constructor() {            this.parent= {}            this.n=0        }        find(id){            if(this.parent[id] ===undefined){                this.n++                this.parent[id] = id            } else if(this.parent[id] !== id){                this.parent[id] = this.find(this.parent[id])            }            return this.parent[id]        }        union(x,y){            const pointX = this.find(x)            const pointY = this.find(y)            if(pointX !== pointY){                this.parent[pointX] = pointY                this.n--            }        }    }    const unionFind = new UnionFind()    for(let [x,y] of stones){        unionFind.union(x,~y)    }    return stones.length - unionFind.n};console.log(removeStones([[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]))console.log(removeStones([[0,0],[0,2],[1,1],[2,0],[2,2]]))console.log(removeStones([[0,0]]))const removeStones2 = (stones) => {    class Union {        constructor() {            this.group = {}            this.cnt = 0        }        find(id){            if(this.group[id]=== undefined){                this.group[id] = id                this.cnt++            }            else if(this.group[id] !== id){                this.group[id] = this.find(this.group[id])            }            return this.group[id]        }        union(x,y){            const routeX = this.find(x)            const routeY = this.find(y)            if(routeX !== routeY){                this.group[routeX] = routeY                this.cnt--            }        }    }    const union = new Union()    for(const [x,y] of stones){        union.union(x,~y)    }    return stones.length - union.cnt}console.log(removeStones2([[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]))console.log(removeStones2([[0,0],[0,2],[1,1],[2,0],[2,2]]))console.log(removeStones2([[0,0]]))