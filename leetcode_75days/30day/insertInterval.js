// 57. Insert Interval// Medium//// 6190//// 426//// Add to List//// Share// You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.////     Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).//// Return intervals after the insertion.////////     Example 1://// Input: intervals = [[1,3],[6,9]], newInterval = [2,5]// Output: [[1,5],[6,9]]// Example 2://// Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]// Output: [[1,2],[3,10],[12,16]]// Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].//////     Constraints://// 0 <= intervals.length <= 104// intervals[i].length == 2// 0 <= starti <= endi <= 105// intervals is sorted by starti in ascending order.//     newInterval.length == 2// 0 <= start <= end <= 105// Accepted// 623,262// Submissions// 1,642,078const insert = function (intervals, newInterval) {    if(intervals.length===0)return [newInterval]    let result = []    let isEnd = false    let pt = -1//     수도코드// 1. 뉴인터벌의 첫번째 보다 인터벌 마지막이 작다면 인터벌을 넣어줘야함// => 그냥 인터벌이 뉴인터벌보다 작기 때문에// 2. 그게 아니면서 뉴인터벌 마지막이 인터벌 첫번째보다 작으면 결과배열에 뉴인터벌 넣어주고 반복문 종료 및 끝난것을 체크함// 3. 이 외에는 뉴 인터벌과 인터벌 작은값,큰값을 넣어줌// 마지막으로// 체크한게 이뤄지지않았으면 뉴인터벌을 맨마지막에 넣어주고// 체크한게 발생했으면 리절트를 앞에 인터벌 종료되고 이후것들을 다 넣어준다.    while( pt< intervals.length -1){        pt++        let [start, end] = intervals[pt]        if(newInterval[0] > end ){            result.push([start,end])        }else if(newInterval[1]<start){            result.push(newInterval)            isEnd=true            break        }else{            newInterval[0] = Math.min(start,newInterval[0])            newInterval[1] = Math.max(end,newInterval[1])        }    }    if(isEnd){        return [...result, ...intervals.slice(pt)]    }else{        return [...result,newInterval]    }};