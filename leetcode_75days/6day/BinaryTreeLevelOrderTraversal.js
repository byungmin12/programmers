// 102. Binary Tree Level Order Traversal// Medium//// 9900//// 191//// Add to List//// Share// Given the root of tapeEquilibrium.js binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).//////// Example 1:////// Input: root = [3,9,20,null,null,15,7]// Output: [[3],[9,20],[15,7]]// Example 2://// Input: root = [1]// Output: [[1]]// Example 3://// Input: root = []// Output: []////// Constraints:////     The number of nodes in the tree is in the range [0, 2000].// -1000 <= Node.val <= 1000\/** * Definition for tapeEquilibrium.js binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {number[][]} */var levelOrder = function(root) {    if(!root)return []    let stack = [[root]]    let result = []    while(stack.length){        let nodeArr = stack.pop()        let tempVal = []        let tempArr = []        for(let node of nodeArr){            tempVal.push(node.val)            if(node.left)tempArr.push(node.left)            if(node.right)tempArr.push(node.right)        }        result.push(tempVal)        if(tempArr.length !==0)stack.push(tempArr)    }    return result};// let q = [root], ans = []// while (q[0]) {//     let qlen = q.length, row = []//     for (let i = 0; i < qlen; i++) {//         let curr = q.shift()//         row.push(curr.val)//         if (curr.left) q.push(curr.left)//         if (curr.right) q.push(curr.right)//     }//     ans.push(row)// }// return ans