// 62. Unique Paths// Medium//// 11144//// 334//// Add to List//// Share// There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.////     Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.////     The test cases are generated so that the answer will be less than or equal to 2 * 109.//////// Example 1:////// Input: m = 3, n = 7// Output: 28// Example 2://// Input: m = 3, n = 2// Output: 3// Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner://     1. Right -> Down -> Down// 2. Down -> Down -> Right// 3. Down -> Right -> Down////// Constraints:////     1 <= m, n <= 100// Accepted// 1.1M// Submissions// 1.8M62. Unique Paths// // Medium// //// // 11144// //// // 334// //// // Add to List// //// // Share// // There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.// //// //     Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.// //// //     The test cases are generated so that the answer will be less than or equal to 2 * 109.// //// //// //// // Example 1:// //// //// // Input: m = 3, n = 7// // Output: 28// // Example 2:// //// // Input: m = 3, n = 2// // Output: 3// // Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:// //     1. Right -> Down -> Down// // 2. Down -> Down -> Right// // 3. Down -> Right -> Down// //// //// // Constraints:// //// //     1 <= m, n <= 100// // Accepted// // 1.1M// // Submissions// // 1.8M/** * @param {number} m * @param {number} n * @return {number} */var uniquePaths = function(m, n) {    //solution1 DP//     const dp = new Array(m + 1).fill(0);//     for(let i = 0; i < dp.length; i++) {//         dp[i] = new Array(n + 1).fill(1);//     }//     for(let row = m-1 ; row > 0 ; row--){//         for(let col = n-1 ; col > 0 ; col--){//             dp[row][col]= dp[row + 1][col] + dp[row][col + 1]//         }//     }//     return dp[1][1]    //solution2 recursive + memoization    const memo = new Array(m + 1).fill(0);    for(let i = 0; i < memo.length; i++) {        memo[i] = new Array(n + 1).fill(-1);    }    return recursiveFunc(1,1,memo)    function recursiveFunc (row,col,memo){        if(row === m && col === n) return 1;        if(row > m || col > n) return 0;        if(memo[row][col]=== -1){            let right = recursiveFunc(row,col+1,memo)            let down = recursiveFunc(row+1,col,memo)            memo[row][col] = right + down        }        return memo[row][col]    }};