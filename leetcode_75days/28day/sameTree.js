// 100. Same Tree// Easy//// 7347//// 156//// Add to List//// Share// Given the roots of two binary trees p and q, write a function to check if they are the same or not.////     Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.////////     Example 1:////// Input: p = [1,2,3], q = [1,2,3]// Output: true// Example 2:////// Input: p = [1,2], q = [1,null,2]// Output: false// Example 3:////// Input: p = [1,2,1], q = [1,1,2]// Output: false////// Constraints:////     The number of nodes in both trees is in the range [0, 100].// -104 <= Node.val <= 104// Accepted// 1.3M// Submissions// 2.2Mfunction isSameTree(p, q) {    if (!p && !q) return true;    if (!p || !q || p.val !== q.val) return false;    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);}/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function(p, q) {    let queue = []    let pt = 0    queue.push([p,q])    while(queue[pt]){        let cur = queue[pt]        let left = cur[0]        let right = cur[1]        if (!left && !right) return true;        if (!left || !right) return false;        if (left.val !== right.val) return false;        if(left.left || right.left){            queue.push([left.left,right.left])        }        if(left.right || right.right){            queue.push([left.right,right.right])        }        pt++    }    return true};