// 232. Implement Queue using Stacks// Easy//// 4492//// 288//// Add to List//// Share// Implement tapeEquilibrium.js first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of tapeEquilibrium.js normal queue (push, peek, pop, and empty).//// Implement the MyQueue class://// void push(int x) Pushes element x to the back of the queue.//     int pop() Removes the element from the front of the queue and returns it.//     int peek() Returns the element at the front of the queue.//     boolean empty() Returns true if the queue is empty, false otherwise.//     Notes://// You must use only standard operations of tapeEquilibrium.js stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.//     Depending on your language, the stack may not be supported natively. You may simulate tapeEquilibrium.js stack using tapeEquilibrium.js list or deque (double-ended queue) as long as you use only tapeEquilibrium.js stack's standard operations.////// Example 1://// Input//     ["MyQueue", "push", "push", "peek", "pop", "empty"]//     [[], [1], [2], [], [], []]// Output//     [null, null, null, 1, 1, false]//// Explanation// MyQueue myQueue = new MyQueue();// myQueue.push(1); // queue is: [1]// myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)// myQueue.peek(); // return 1// myQueue.pop(); // return 1, queue is [2]// myQueue.empty(); // return false////// Constraints:////     1 <= x <= 9// At most 100 calls will be made to push, pop, peek, and empty.//     All the calls to pop and peek are valid.//////     Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.////     Accepted// 519.5K// Submissions// 851.4Kconst MyQueue = function() {    this.stack = []    this.pt = 0    this.shiftPt = 0};/** * @param {number} x * @return {void} */MyQueue.prototype.push = function(x) {    this.stack[this.pt] = x    this.pt++};/** * @return {number} */MyQueue.prototype.pop = function() {    let temp = this.shiftPt    this.shiftPt++    return this.stack[temp]};/** * @return {number} */MyQueue.prototype.peek = function() {    return this.stack[this.shiftPt]};/** * @return {boolean} */MyQueue.prototype.empty = function() {    return this.pt===this.shiftPt};/** * Your MyQueue object will be instantiated and called as such: * const obj = new MyQueue() * obj.push(x) * const param_2 = obj.pop() * const param_3 = obj.peek() * const param_4 = obj.empty() */