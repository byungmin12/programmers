function solution(board) {    // 보드게임판의 크기를 구한다.    const n = board.length;    const m = board[0].length;    // 로봇의 시작 위치와 목표 위치를 찾는다.    let start, goal;    for (let i = 0; i < n; i++) {        for (let j = 0; j < m; j++) {            if (board[i][j] === 'R') {                start = { x: i, y: j };            } else if (board[i][j] === 'G') {                goal = { x: i, y: j };            }        }    }    // BFS 알고리즘을 사용하여 최소 이동 횟수를 계산한다.    const queue = [];    const visited = new Set();    queue.push(start);    visited.add(`${start.x},${start.y}`);    let steps = 0;    while (queue.length > 0) {        const size = queue.length;        for (let i = 0; i < size; i++) {            const curr = queue.shift();            if (curr.x === goal.x && curr.y === goal.y) {                return steps;            }            for (let dir of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {                let next = { x: curr.x , y: curr.y };                while(true){                    next = { x: next.x + dir[0], y: next.y + dir[1] };                    if (next.x < 0 || next.x >= n || next.y < 0 || next.y >= m || board[next.x][next.y] === 'D'){                        next = { x: next.x - dir[0], y: next.y - dir[1] };                        break;                    }                }                if (visited.has(`${next.x},${next.y}`)) {                    continue;                }                queue.push(next);                visited.add(`${next.x},${next.y}`);            }        }        steps++;    }    // 목표 지점에 도달할 수 없는 경우 -1을 반환한다.    return -1;}