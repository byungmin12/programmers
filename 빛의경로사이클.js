function solution(grid) {    const H = grid.length;    const W = grid[0].length;    const dy = [-1, 0, 1, 0]; // 위, 오른쪽, 아래, 왼쪽 순서    const dx = [0, 1, 0, -1];    let answer = [];    const visited = Array.from({ length: H }, () => Array.from({ length: W }, () => Array(4).fill(0)));    //들어갔는지 확인    for (let y = 0; y < H; y++) {        for (let x = 0; x < W; x++) {            for (let d = 0; d < 4; d++) {                if (visited[y][x][d] !== 0) continue;                // 이미들어가면 더 이상 확인할 필요가 없음                // x,y d(direction)                let count = 0;                let cycle = 0;                let ny = y;                let nx = x;                let nd = d;                while (true) {                    visited[ny][nx][nd] = count;                    count++;                    // 다음 칸 좌표                    const ty = ny + dy[nd];                    const tx = nx + dx[nd];                    // 범위를 벗어날 경우 반대편 좌표 계산                    if (ty < 0) ny = H - 1;                    else if (ty === H) ny = 0;                    else ny = ty;                    if (tx < 0) nx = W - 1;                    else if (tx === W) nx = 0;                    else nx = tx;                    // 방향 전환                    if (grid[ny][nx] === 'S') {                        // 직진                        // 현재 방향 그대로                    } else if (grid[ny][nx] === 'L') {                        // 좌회전                        nd = (nd + 3) % 4;                    } else if (grid[ny][nx] === 'R') {                        // 우회전                        nd = (nd + 1) % 4;                    }                    // 시작 지점으로 돌아온 경우                    if (ny === y && nx === x && nd === d) {                        cycle = count;                        break;                    }                    // 이미 방문한 좌표인 경우                    if (visited[ny][nx][nd] !== 0) {                        cycle = count - visited[ny][nx][nd];                        break;                    }                }                answer.push(cycle);            }        }    }    return answer.sort((a, b) => a - b);}